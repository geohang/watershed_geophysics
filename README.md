# Watershed Geophysics Modeling and Inversion (WatershedGeo)

`WatershedGeo` is a Python package designed for integrated geophysical modeling and inversion, particularly tailored for watershed monitoring applications. It provides tools for Electrical Resistivity Tomography (ERT), seismic tomography, processing of hydrological model outputs (e.g., MODFLOW, Parflow), and petrophysical conversions.

## Features

*   **Core Utilities**: Mesh creation and management, 2D/3D interpolation routines.
*   **Geophysical Forward Modeling**: ERT and seismic forward modeling capabilities.
*   **Geophysical Inversion**:
    *   Standard ERT inversion.
    *   Time-lapse ERT inversion (including 4D and windowed approaches).
*   **Hydrological Model Output Processing**: Tools to read and process outputs from MODFLOW and Parflow (optional).
*   **Petrophysics**: Functions to convert between hydrogeological properties (e.g., water content, porosity) and geophysical parameters (e.g., resistivity, seismic velocity) using various models (Archie, Waxman-Smits, VRH, DEM, etc.).
*   **Hydro-Geophysical Coupling**: Utilities to convert hydrological model outputs into inputs for geophysical simulations.
*   **Modular Structure**: Organized into modules for geophysics, hydrology, core functions, forward modeling, inversion, petrophysics, and solvers.

## Installation

To install the `WatershedGeo` package, clone this repository and install it using pip. It's recommended to install it in a virtual environment.

```bash
git clone <repository_url>
cd watershed_geophysics
pip install -e .
```

This will install the package in editable mode. If you prefer a standard installation, you can use:

```bash
pip install .
```

### Dependencies

The package relies on several scientific Python libraries, including:

*   NumPy
*   SciPy
*   PyGIMLi (for geophysical modeling and inversion)
*   Matplotlib (for plotting)
*   Joblib (for parallel processing in solvers)
*   CuPy (optional, for GPU acceleration in solvers)
*   Parflow (optional, for reading Parflow model outputs)
*   Flopy (optional, for reading MODFLOW model outputs)

Ensure these dependencies are installed. `PyGIMLi` might require specific installation steps; please refer to its official documentation. Other dependencies can typically be installed via pip.

## Basic Usage

Here are some conceptual examples of how to use the package. For detailed, runnable examples, please refer to the Jupyter notebooks in the `examples/` directory.

### 1. ERT Inversion

```python
from watershed_geophysics.inversion import ERTInversion
from watershed_geophysics.core.mesh_utils import MeshCreator # If creating mesh separately

# Initialize ERT inversion
# ert_data_file should be a path to your ERT data (e.g., a .dat file)
# mesh can be pre-created or will be generated by the inverter
inverter = ERTInversion(data_file='path/to/your/ert_data.dat')

# Optional: Customize inversion parameters
inverter.parameters['lambda_val'] = 50
inverter.parameters['max_iterations'] = 15

# Run the inversion
results = inverter.run()

# Access results
final_resistivity_model = results.final_model
coverage = results.coverage

# Plot results
fig, ax = results.plot_model(coverage_threshold=-2.0) # Adjust threshold as needed
fig.savefig('inversion_result.png')
```

### 2. Forward Modeling (ERT)

```python
from watershed_geophysics.forward import ERTForwardModeling
from watershed_geophysics.core.mesh_utils import MeshCreator
import pygimli as pg
import numpy as np

# Assume 'mesh' is a PyGIMLi mesh and 'scheme' is an ERT data container (scheme)
# For example, create a simple mesh:
mesh_creator = MeshCreator()
# (Details for creating a mesh from layers or ertData would go here if needed)
# For a basic example, let's assume a mesh is loaded or created.
# mesh = pg.load('path/to/mesh.bms') or created using MeshCreator

# Example: Create a simple mesh for demonstration
mesh = pg.createGrid(x=np.linspace(0, 100, 50), y=np.linspace(-20, 0, 10))
mesh = pg.meshtools.appendTriangleBoundary(mesh, xbound=50, ybound=50)

# Create an ERT data scheme (e.g., Wenner alpha)
scheme = pg.physics.ert.createData(elecs=np.linspace(0, 50, 26), schemeName='wa')

# Resistivity model (values for each cell in the mesh)
resistivity_model = np.ones(mesh.cellCount()) * 100  # Homogeneous model
resistivity_model[mesh.cellMarkers() == 2] = 50 # Example heterogeneity

# Initialize forward modeling
fwd_modeler = ERTForwardModeling(mesh=mesh, data=scheme)

# Compute synthetic data
synthetic_data_response = fwd_modeler.forward(resistivity_model, log_transform=False)

# Or use the class method to generate data with noise
# x_electrodes = np.linspace(0, 50, 26)
# synthetic_data_container, sim_mesh = ERTForwardModeling.create_synthetic_data(
#     xpos=x_electrodes,
#     mesh=mesh, # Optional, can be created internally
#     res_models=resistivity_model,
#     schemeName='wa',
#     noise_level=0.05
# )
# print(f"Generated data: {synthetic_data_container}")
```

### 3. Converting MODFLOW Output to ERT Data

```python
from watershed_geophysics.model_output import MODFLOWWaterContent, MODFLOWPorosity
from watershed_geophysics.core.interpolation import ProfileInterpolator
from watershed_geophysics.Hydro_modular import hydro_to_ert
import numpy as np
import pygimli as pg

# --- Setup (replace with actual data loading and parameters) ---
# Example: Assume these are loaded or defined
# model_dir = 'path/to/modflow_workspace'
# model_name = 'mymodel' # MODFLOW name file without extension
# idomain = np.ones((3, 10, 10)) # Example idomain (nlay, nrow, ncol)
#
# # Profile for interpolation
# p1 = [0, 5]  # Start point (col, row) for profile
# p2 = [9, 5]  # End point (col, row) for profile
# surface_elevation_data = np.random.rand(10, 10) * 10 # Example surface elevation
#
# interpolator = ProfileInterpolator(p1, p2, surface_elevation_data, num_points=50)
#
# # Mesh (can be created based on profile or loaded)
# mesh = pg.createGrid(x=np.linspace(0, interpolator.L_profile[-1], 50), y=np.linspace(-15, 0, 10))
# mesh = pg.meshtools.appendTriangleBoundary(mesh, xbound=20, ybound=20)
# mesh.setCellMarkers(np.ones(mesh.cellCount())) # Simple marker
#
# # Water content and porosity (example placeholder)
# # In a real case, load these using MODFLOWWaterContent and MODFLOWPorosity
# wc_data_3d = np.random.rand(3, 10, 10) * 0.3 # (nlay, ny, nx)
# porosity_data_3d = np.ones((3, 10, 10)) * 0.35
#
# # For hydro_to_ert, data needs to be on the mesh or interpolable
# # This example assumes wc_data_3d and porosity_data_3d are already suitable for interpolation
# # or direct use if they match mesh structure (which is not the case here, just for illustration)
# # A more complete example would use interpolator.interpolate_to_mesh()
#
# wc_on_mesh = np.ones(mesh.cellCount()) * 0.25 # Placeholder
# porosity_on_mesh = np.ones(mesh.cellCount()) * 0.3
#
# layer_markers_in_mesh = [1] # Assuming a single layer marker in this simple mesh
#
# rho_params = {
#     'rho_sat': [100], # Saturated resistivity for marker 1
#     'n': [2.0],       # Cementation exponent for marker 1
#     'sigma_s': [0.01] # Surface conductivity for marker 1
# }
# --- End Setup ---

# This is a conceptual guide; actual implementation requires careful data handling.
# print("Note: The following hydro_to_ert call is conceptual due to simplified placeholder data.")
# try:
#     synthetic_ert_data, resistivity_model_on_mesh = hydro_to_ert(
#         water_content=wc_on_mesh, # Should be water content on mesh cells
#         porosity=porosity_on_mesh,    # Should be porosity on mesh cells
#         mesh=mesh,
#         profile_interpolator=interpolator, # Used if wc/porosity are 3D arrays
#         marker_labels=layer_markers_in_mesh, # Markers present in the mesh
#         rho_parameters=rho_params,
#         electrode_spacing=2.0,
#         num_electrodes=48,
#         scheme_name='dd' # Dipole-dipole
#     )
#     print(f"Synthetic ERT data generated: {synthetic_ert_data}")
# except Exception as e:
#     print(f"Conceptual hydro_to_ert example failed: {e}. See detailed examples in notebooks.")

```
*Note: The hydro_to_ert example above is highly conceptual due to the complexity of preparing inputs. Please see the `examples/` notebooks for functional demonstrations.*

## Examples

The `examples/` directory contains Jupyter notebooks that demonstrate various functionalities of the `WatershedGeo` package. These include:

*   Processing hydrological model outputs (`Ex_model_output.ipynb`)
*   Monte Carlo simulations for water content estimation (`MC_watercontent.ipynb`)
*   Seismic travel time tomography (`Seismic_travel_time.ipynb`)
*   Integrating structural information with water content mapping (`Structure_WC.ipynb`)
*   Building subsurface models (`Subsurface_model.ipynb`)
*   Time-lapse ERT inversion (`TL_inversion.ipynb`, `Time_lapse_measurement.ipynb`)
*   Example workflows (`workflow.ipynb`)

To run these examples, navigate to the `examples/` directory and start a Jupyter Notebook server:

```bash
cd examples
jupyter notebook
```

Ensure you have Jupyter Notebook installed (`pip install notebook`).

## Modules Overview

*   **`watershed_geophysics.core`**: Basic utilities for mesh generation, interpolation.
*   **`watershed_geophysics.Geophy_modular`**: Higher-level geophysical processing (seismic processing, ERT-to-WaterContent conversion, structure integration).
*   **`watershed_geophysics.Hydro_modular`**: Utilities for converting hydrological model outputs to geophysical model inputs.
*   **`watershed_geophysics.forward`**: Forward modeling for ERT and seismic methods.
*   **`watershed_geophysics.inversion`**: Inversion algorithms for ERT, including time-lapse.
*   **`watershed_geophysics.model_output`**: Reading and processing outputs from MODFLOW and Parflow.
*   **`watershed_geophysics.petrophysics`**: Petrophysical relationships (e.g., resistivity-saturation, velocity-porosity).
*   **`watershed_geophysics.solvers`**: Linear solvers used in inversions.

## Contributing

Contributions are welcome! If you'd like to contribute, please:

1.  Fork the repository.
2.  Create a new branch for your feature or bug fix.
3.  Make your changes, including tests if applicable.
4.  Ensure your code follows existing style conventions.
5.  Submit a pull request.

(If there's a more formal contribution guide or code of conduct, link it here.)

## License

This project is licensed under the MIT License - see the `LICENSE` file for details (assuming MIT, please update if different).
